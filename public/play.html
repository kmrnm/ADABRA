<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADABRA • Play</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Arial;
      padding: 24px;
    }

    .card {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 16px;
      max-width: 720px;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin: 12px 0;
    }

    input {
      padding: 12px;
      font-size: 18px;
      width: 180px;
      text-transform: uppercase;
    }

    button {
      padding: 12px 16px;
      font-size: 18px;
      cursor: pointer;
    }

    #buzz {
      width: 100%;
      font-size: 34px;
      padding: 22px;
    }

    .muted {
      color: #666;
    }

    .ok {
      color: #0a7;
    }

    .err {
      color: #c00;
    }

    .pill {
      display: inline-block;
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 999px;
    }

    #time {
      font-variant-numeric: tabular-nums;
      font-size: 18px;
    }

    .teams {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .teamBtn {
      min-width: 120px;
    }

    .bigScore {
      font-size: 28px;
      font-weight: 900;
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>

<body>
  <h1>ADABRA • Player</h1>

  <div class="card">
    <div class="row">
      <input id="roomCode" placeholder="ROOM" maxlength="6" />
      <button id="join">Join</button>
    </div>

    <div class="row">
      <span class="pill">Room: <strong id="currentRoom" class="muted">none</strong></span>
      <span class="pill">Team: <strong id="team" class="muted">none</strong></span>
      <span class="pill">Phase: <strong id="phase" class="muted">—</strong></span>
      <span class="pill">Time: <strong id="time" class="muted">00:00.0</strong></span>
    </div>

    <div class="row">
      <span class="pill">Your team score: <strong id="myScore" class="bigScore muted">—</strong></span>
    </div>

    <div class="row">
      <div class="muted">Choose team (only once):</div>
    </div>

    <div id="teams" class="teams"></div>

    <div id="nameBox" style="display:none; margin-top: 10px;">
      <div class="muted">Set your team name (one time):</div>
      <div class="row">
        <input id="teamNameInput" placeholder="e.g. Avengers" maxlength="16"
          style="width: 260px; text-transform:none;" />
        <button id="saveTeamName">Save</button>
      </div>
    </div>

    <p id="msg" class="muted">Join a room, select your team, then wait for the beep.</p>

    <div id="lockBanner" class="pill muted"
      style="display:none; width:100%; justify-content:center; text-align:center; font-weight:700;">
      —
    </div>


    <button id="buzz">BUZZ</button>
  </div>

  <audio id="beepAudio" src="/sounds/beep.mp3" preload="auto"></audio>
  <audio id="buzzAudio" src="/sounds/buzz.mp3" preload="auto"></audio>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    const roomInput = document.getElementById("roomCode");
    const joinBtn = document.getElementById("join");

    const currentRoomEl = document.getElementById("currentRoom");
    const teamEl = document.getElementById("team");
    const phaseEl = document.getElementById("phase");
    const timeEl = document.getElementById("time");
    const myScoreEl = document.getElementById("myScore");

    const nameBox = document.getElementById("nameBox");
    const teamNameInput = document.getElementById("teamNameInput");
    const saveTeamNameBtn = document.getElementById("saveTeamName");

    const msgEl = document.getElementById("msg");
    const buzzBtn = document.getElementById("buzz");
    const teamsEl = document.getElementById("teams");
    const lockBannerEl = document.getElementById("lockBanner");

    const beepAudio = document.getElementById("beepAudio");
    const buzzAudio = document.getElementById("buzzAudio");

    let currentRoom = null;
    let lastState = null;

    let mySocketId = null;
    socket.on("connect", () => { mySocketId = socket.id; });

    // message “locks”: if set, we keep it until explicitly cleared
    let stickyMsg = null; // { text, cls } or null

    let lastRoundNumber = null;

    function setMsg(text, cls = "muted", { sticky = false } = {}) {
      msgEl.className = cls;
      msgEl.textContent = text;
      stickyMsg = sticky ? { text, cls } : null;
    }

    function hardDisableBuzzNow() {
      buzzBtn.disabled = true;
    }

    function renderStickyMsgIfAny() {
      if (!stickyMsg) return false;
      msgEl.className = stickyMsg.cls;
      msgEl.textContent = stickyMsg.text;
      return true;
    }

    // stable playerId (survives refresh)
    function getOrCreatePlayerId() {
      const key = "adabra_playerId_v1";
      let id = localStorage.getItem(key);
      if (!id) {
        id = (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + "_" + Math.random().toString(16).slice(2));
        localStorage.setItem(key, id);
      }
      return id;
    }
    const playerId = getOrCreatePlayerId();

    function roomTeamKey(roomCode) {
      return `adabra_team_v1_${roomCode}`;
    }

    function formatMs(ms) {
      const m = Math.floor(ms / 60000);
      const s = Math.floor((ms % 60000) / 1000);
      const t = Math.floor((ms % 1000) / 100);
      return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}.${t}`;
    }

    function getQueryRoom() {
      const params = new URLSearchParams(location.search);
      const r = params.get("room");
      return r ? r.trim().toUpperCase() : "";
    }

    function getSavedTeam(roomCode) {
      return localStorage.getItem(roomTeamKey(roomCode)) || null;
    }

    function saveTeam(roomCode, teamId) {
      localStorage.setItem(roomTeamKey(roomCode), teamId);
    }

    function renderTeamButtons(teams, chosenTeamId, takenTeams, myPlayerId) {
      const taken = new Map((takenTeams || []).map(x => [x.teamId, x.playerId]));

      teamsEl.innerHTML = "";
      for (const t of teams) {
        const btn = document.createElement("button");
        btn.className = "teamBtn";

        const takenBy = taken.get(t.id);
        const isTakenByOther = Boolean(takenBy && takenBy !== myPlayerId);

        btn.textContent = isTakenByOther ? `${t.name} (Taken)` : `${t.name}`;

        // If you already chose a team: disable all team buttons (same as before)
        // If not chosen: disable only teams taken by others
        btn.disabled = Boolean(chosenTeamId) || isTakenByOther;

        btn.onclick = () => {
          if (chosenTeamId || isTakenByOther) return;
          socket.emit("setTeam", { teamId: t.id });
        };

        teamsEl.appendChild(btn);
      }
    }

    function updateMyScore() {
      const myTeam = teamEl.textContent !== "none" ? teamEl.textContent : null;
      if (!myTeam || !lastState) {
        myScoreEl.textContent = "—";
        myScoreEl.className = "bigScore muted";
        return;
      }
      const t = (lastState.teams || []).find(x => x.id === myTeam);
      if (!t) {
        myScoreEl.textContent = "—";
        myScoreEl.className = "bigScore muted";
        return;
      }
      myScoreEl.textContent = String(t.score);
      myScoreEl.className = "bigScore ok";
    }

    // ---- NEW: locked-out handling + buzz button enable/disable ----
    function updateBuzzAvailability() {
      const chosenTeam = getSavedTeam(currentRoom) || (teamEl.textContent !== "none" ? teamEl.textContent : null);
      if (!chosenTeam || !lastState) {
        buzzBtn.disabled = true;
        return;
      }

      const lockedOut = new Set(lastState.lockedOutTeams || []);
      const isLockedOut = lockedOut.has(chosenTeam);

      // disable buzz if locked out OR round not armed
      if (isLockedOut) {
        buzzBtn.disabled = true;
        setMsg("Your team is locked out for this round.", "err", { sticky: true });
        return;
      }

      // not locked out
      buzzBtn.disabled = (lastState.phase !== "armed");
    }

    function joinRoom(code) {
      const roomCode = String(code || "").trim().toUpperCase();
      if (!roomCode) return setMsg("Enter a room code.", "err");

      currentRoom = roomCode;
      currentRoomEl.textContent = roomCode;
      currentRoomEl.className = "ok";

      const saved = getSavedTeam(roomCode);
      if (saved) {
        teamEl.textContent = saved;
        teamEl.className = "ok";
      } else {
        teamEl.textContent = "none";
        teamEl.className = "muted";
      }

      socket.emit("joinRoom", { roomCode, playerId });
    }

    // auto join from link
    const queryRoom = getQueryRoom();
    if (queryRoom) {
      roomInput.value = queryRoom;
      joinRoom(queryRoom);
    }

    joinBtn.onclick = () => joinRoom(roomInput.value);

    // ---- NEW: spacebar triggers buzz ----
    // (prevents page scroll, and triggers buzz if allowed)
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (!buzzBtn.disabled) buzzBtn.click();
      }
    });

    // ---- NEW: play local buzz sound when user clicks buzz ----
    function playBuzzSound() {
      buzzAudio.currentTime = 0;
      buzzAudio.play().catch(() => { });
    }

    buzzBtn.onclick = () => {
      if (buzzBtn.disabled) return;
      playBuzzSound();
      hardDisableBuzzNow();
      socket.emit("buzz");
    };

    saveTeamNameBtn.onclick = () => {
      const name = teamNameInput.value;
      socket.emit("setTeamName", { name });
    };

    socket.on("beep", () => {
      // new round start clears sticky “locked out” etc.
      stickyMsg = null;

      beepAudio.currentTime = 0;
      beepAudio.play().catch(() => { });
    });

    socket.on("timeUp", () => {
      setMsg("Time is up.", "err", { sticky: true });
      hardDisableBuzzNow();
    });

    socket.on("joinedRoom", ({ roomCode }) => {
      setMsg(`Joined room ${roomCode}. Select your team once, then wait for the beep.`, "ok");
    });

    socket.on("teamSet", ({ teamId }) => {
      teamEl.textContent = teamId;
      teamEl.className = "ok";
      if (currentRoom) saveTeam(currentRoom, teamId);
      setMsg(`Team ${teamId} selected.`, "ok");
      if (lastState) renderTeamButtons(lastState.teams, teamId);
      updateMyScore();
      updateBuzzAvailability();
    });

    socket.on("roomState", (state) => {
      if (!currentRoom || state.roomCode !== currentRoom) return;

      lastState = state;

      // New round, clear sticky messages (lockout, etc.)
      if (lastRoundNumber === null) lastRoundNumber = state.roundNumber;
      if (state.roundNumber !== lastRoundNumber) {
        stickyMsg = null;
        lastRoundNumber = state.roundNumber;
      }

      // New round, reset phase clears sticky messages
      if (state.phase === "lobby") stickyMsg = null;


      // ----- LOCK BANNER LOGIC -----
      if (state.phase === "locked" && state.lastBuzz) {
        lockBannerEl.style.display = "block";

        const myTeam = getSavedTeam(currentRoom) || (teamEl.textContent !== "none" ? teamEl.textContent : null);

        if (myTeam && state.lastBuzz.teamId === myTeam) {
          lockBannerEl.textContent = "LOCKED — Your team is answering";
          lockBannerEl.className = "pill ok";
        } else {
          lockBannerEl.textContent = `LOCKED — Team ${state.lastBuzz.teamId} is answering`;
          lockBannerEl.className = "pill muted";
        }
      } else {
        lockBannerEl.style.display = "none";
      }

      // ===== STOP message updates while locked =====
      if (state.phase === "locked" && state.lastBuzz) {
        return;
      }

      phaseEl.textContent = state.phase;
      phaseEl.className = state.phase === "armed" ? "ok" : "muted";

      timeEl.textContent = formatMs(state.remainingMs);

      const chosenTeam = getSavedTeam(currentRoom) || (teamEl.textContent !== "none" ? teamEl.textContent : null);
      renderTeamButtons(state.teams, chosenTeam, state.takenTeams, playerId);

      // TEAM NAME BOX SHOW/HIE
      const lockedNames = new Set(state.teamNameLocked || []);
      const takenMap = new Map((state.takenTeams || []).map(x => [x.teamId, x.playerId]));
      const iOwnThisTeam = chosenTeam && takenMap.get(chosenTeam) === playerId;

      if (chosenTeam && iOwnThisTeam && !lockedNames.has(chosenTeam)) {
        nameBox.style.display = "block";
      } else {
        nameBox.style.display = "none";
      }

      updateMyScore();
      updateBuzzAvailability();

      if (!chosenTeam) {
        buzzBtn.disabled = true;
        setMsg("Select your team once.", "muted");
        return;
      }

      // If a sticky message exists (locked out, etc.), keep it
      if (renderStickyMsgIfAny()) return;

      // ---- NEW: show who buzzed first for everyone ----
      if (state.phase === "locked" && state.lastBuzz) {
        if (state.lastBuzz.by === mySocketId) {
          setMsg("You buzzed first. Waiting for host decision…", "ok");
        } else {
          setMsg(`Team ${state.lastBuzz.teamId} buzzed first. Wait…`, "muted");
        }
        return;
      }

      if (state.phase === "lobby") setMsg("Waiting for beep…", "muted");
      if (state.phase === "armed") setMsg("Round started. Buzz now!", "ok");
    });

    socket.on("buzzed", ({ teamId, roomCode }) => {
      if (roomCode !== currentRoom) return;

      hardDisableBuzzNow();

      const myTeam =
        getSavedTeam(currentRoom) || (teamEl.textContent !== "none" ? teamEl.textContent : null);

      if (myTeam && teamId === myTeam) {
        setMsg("Your team buzzed first. Waiting for host decision…", "ok");
      } else {
        setMsg(`Team ${teamId} buzzed first. Wait…`, "muted");
      }
    });

    socket.on("buzzRejected", ({ reason }) => {
      if (reason === "NO_TEAM") setMsg("Choose your team first.", "err");
      else if (reason === "NOT_ARMED") setMsg("Too early. Wait for the beep.", "err");
      else if (reason === "TIME_UP") setMsg("Too late. Time is up.", "err");
      else if (reason === "TEAM_LOCKED_OUT") setMsg("Your team is locked out this round.", "err", { sticky: true });
    });

    socket.on("errorMsg", (text) => setMsg(text, "err"));
  </script>
</body>

</html>